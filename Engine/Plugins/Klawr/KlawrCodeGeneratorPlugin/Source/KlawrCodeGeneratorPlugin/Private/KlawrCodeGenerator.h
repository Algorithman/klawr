//-------------------------------------------------------------------------------
// The MIT License (MIT)
//
// Copyright (c) 2014 Vadim Macagon
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//-------------------------------------------------------------------------------
#pragma once

namespace Klawr {

class FCodeFormatter;

/**
 * Generates a C# wrapper class for each scriptable UE4 class.
 *
 * The generated C# class encapsulates a bunch of delegates that are bound to pointers to native
 * wrapper functions (that are also generated by this class).
 */
class FCodeGenerator
{
public:
	FCodeGenerator(
		const FString& InRootLocalPath, const FString& InRootBuildPath, 
		const FString& InOutputDirectory, const FString& InIncludeBase
	);

	void ExportClass(
		UClass* Class, const FString& SourceHeaderFilename, const FString& GeneratedHeaderFilename,
		bool bHasChanged
	);

	void FinishExport();

private:
	static const FName Name_Vector2D;
	static const FName Name_Vector;
	static const FName Name_Vector4;
	static const FName Name_Quat;
	static const FName Name_Transform;
	static const FName Name_LinearColor;
	static const FName Name_Color;

	static const FString UnmanagedFunctionPointerAttribute;
	static const FString MarshalReturnedBoolAsUint8Attribute;
	static const FString MarshalBoolParameterAsUint8Attribute;
	static const FString ClrHostInterfacesAssemblyName;
	static const FString ClrHostManagedAssemblyName;

	struct FExportedProperty
	{
		FString GetterDelegateName;
		FString GetterDelegateTypeName;
		FString SetterDelegateName;
		FString SetterDelegateTypeName;
		FString NativeGetterWrapperFunctionName;
		FString NativeSetterWrapperFunctionName;
	};

	struct FExportedFunction
	{
		const UFunction* Function;
		bool bHasReturnValue;
		FString NativeWrapperFunctionName;
	};

	/** Path where generated script glue goes **/
	FString GeneratedCodePath;
	/** Local root path **/
	FString RootLocalPath;
	/** Build root path - may be different to RootBuildPath when building remotely. **/
	FString RootBuildPath;
	/** Base include directory */
	FString IncludeBase;
	/** All generated C++ script header filenames. */
	TArray<FString> AllScriptHeaders;
	/** All the generated C# wrapper class filenames. */
	TArray<FString> AllManagedWrapperFiles;
	/** Engine source header filenames for all exported classes. */
	TArray<FString> AllSourceClassHeaders;
	/** Functions that were exported for each class. */
	TMap<const UClass*, TArray<FExportedFunction> > ClassExportedFunctions;
	/** Properties that were exported for each class. */
	TMap<const UClass*, TArray<FExportedProperty> > ClassExportedProperties;

	TSet<FName> ExportedClassNames;
	TArray<const UClass*> AllExportedClasses;

	static bool CanExportClass(const UClass* Class);
	static bool CanExportProperty(const UClass* Class, const UProperty* Property);
	static bool CanExportFunction(const UClass* Class, const UFunction* Function);

	static FString GetClassCPPType(const UClass* Class);
	static FString GetPropertyCPPType(const UProperty* Property);
	static FString GenerateFunctionDispatchParamInitializer(const UProperty* Param);
	static void GenerateFunctionDispatch(const UFunction* Function, FCodeFormatter& GeneratedGlue);

	/** Generate a .csproj for the C# wrapper classes. */
	void GenerateManagedWrapperProject();
	/** Build the generated .csproj of C# wrapper classes. */
	void BuildManagedWrapperProject();
	/** Create a 'glue' file that merges all generated script files */
	void GlueAllNativeWrapperFiles();

	/** Export native and managed wrappers for the given UFunction. */
	void ExportFunction(
		const FString& ClassNameCPP, const UClass* Class, UFunction* Function, 
		FCodeFormatter& NativeGlueCode, FCodeFormatter& ManagedGlueCode
	);
	/** Export native and managed wrappers for the given UProperty. */
	void ExportProperty(
		const FString& ClassNameCPP, UClass* Class, UProperty* Property,
		FCodeFormatter& NativeGlueCode, FCodeFormatter& ManagedGlueCode
	);
	/** Generate a statement returning the given value. */
	void GenerateNativeReturnValueHandler(
		const UProperty* ReturnValue, const FString& ReturnValueName, FCodeFormatter& GeneratedGlue
	);

	FString GenerateManagedReturnValueHandler(const UProperty* ReturnValue);

	/** Check if a property type is supported */
	static bool IsPropertyTypeSupported(const UProperty* Property);
	/** Check if the property type is a pointer. */
	static bool IsPropertyTypePointer(const UProperty* Property);
	/** Check if the property type is a struct that can be used for interop. */
	static bool IsStructPropertyTypeSupported(const UStructProperty* Property);

	static FString GetPropertyNativeType(const UProperty* Property);
	static FString GetPropertyInteropType(const UProperty* Property);
	static FString GetPropertyManagedType(const UProperty* Property);
	static FString GetPropertyInteropTypeAttributes(const UProperty* Property);
	static FString GetPropertyInteropTypeModifiers(const UProperty* Property);

	UProperty* GetNativeWrapperArgsAndReturnType(
		const UFunction* Function, FString& OutFormalArgs, FString& OutActualArgs
	);

	UProperty* GetManagedWrapperArgsAndReturnType(
		const UFunction* Function, FString& OutFormalInteropArgs, FString& OutActualInteropArgs,
		FString& OutFormalManagedArgs, FString& OutActualManagedArgs
	);
		
	void GenerateNativeWrapperFunction(
		const UClass* Class, UFunction* Function, FCodeFormatter& GeneratedGlue
	);

	void GenerateManagedWrapperFunction(
		const UClass* Class, const UFunction* Function, FCodeFormatter& GeneratedGlue
	);

	void GenerateNativePropertyGetterWrapper(
		const FString& ClassNameCPP, const UClass* Class, const UProperty* Property,
		FCodeFormatter& GeneratedGlue, FExportedProperty& ExportedProperty
	);

	void GenerateNativePropertySetterWrapper(
		const FString& ClassNameCPP, const UClass* Class, const UProperty* Property,
		FCodeFormatter& GeneratedGlue, FExportedProperty& ExportedProperty
	);

	void GenerateManagedPropertyWrapper(
		const UClass* Class, const UProperty* Property, FCodeFormatter& GeneratedGlue, 
		FExportedProperty& ExportedProperty
	);

	void GenerateManagedStaticConstructor(const UClass* Class, FCodeFormatter& GeneratedGlue);
	static void GenerateNativeGlueCodeHeader(const UClass* Class, FCodeFormatter& GeneratedGlue);
	void GenerateNativeGlueCodeFooter(const UClass* Class, FCodeFormatter& GeneratedGlue) const;
	void GenerateManagedGlueCodeHeader(const UClass* Class, FCodeFormatter& GeneratedGlue) const;
	void GenerateManagedGlueCodeFooter(const UClass* Class, FCodeFormatter& GeneratedGlue);
	void GenerateManagedScriptObjectClass(const UClass* Class, FCodeFormatter& GeneratedGlue);
	FString GenerateDelegateTypeName(const FString& FunctionName, bool bHasReturnValue) const;
	FString GenerateDelegateName(const FString& FunctionName) const;
	void WriteToFile(const FString& Path, const FString& Content);
	FString RebaseToBuildPath(const FString& Filename) const;
};

} // namespace Klawr
